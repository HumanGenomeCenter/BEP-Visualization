<!DOCTYPE html>
<head>
	<meta charset="utf-8">
	<title>BEP Force</title>
	<link rel="stylesheet" href="../css/bootstrap.css" charset="utf-8">
	<style type="text/css" media="screen">
		body {
			background: #eee;
			margin: 0 auto;
		}
		.container {
		 /* margin: 0 auto; */
		  width: 970px !important;
		}
		svg {
			background: #fff;
		}
	</style>
	
</head>

<body>
	
<div class="container">
	<div class="page-header">
	  <h1>B.E.P Simulator <small>Cancer-subtype Simulation</small></h1>
	</div>
	<div class="row">
		<div class="col-xs-2">
			<p>
				<button type="button" class="btn btn-default" id="addCell">Add Cell</button>
			</p>
			<p>
				<button type="button" class="btn btn-default" id="addManyCells">Add 100 Cells</button>
			</p>
			<p>
				<button type="button" class="btn btn-primary" id="resetCells">Reset</button>
			</p>
			<div class="btn-group">
				<button type="button" class="btn btn-info btn-xs"id="zoomIn"><span class="glyphicon glyphicon-zoom-in"></span></button>
				<button type="button" class="btn btn-info btn-xs"id="zoomOut"><span class="glyphicon glyphicon-zoom-out"></span></button>
				<button type="button" class="btn btn-info btn-xs"id="zoomReset"><span class="glyphicon glyphicon-search"></span></button>
			</div>
		</div>
		<div class="col-xs-10" id="cells"></div>
	</div>
</div>
<script src="../js/d3.min.js"></script>
<script src="../js/jquery-2.0.3.min.js"></script>
<script src="../js/colorbrewer.js"></script>
<script>

// https://gist.github.com/mbostock/3231307

var width = 800,
    height = 500;

// define cell size
var cellRadius = function() {
	return Math.floor(Math.random() * 5 + 10);
//	return 2;
}


/* - - - - - - - - -  Color - - - - - - - - -  */

var getColor = colorbrewer.Set1[6];		//  from Colorbrewer

/* - - - - - - - - -  Color End - - - - - - - - -  */

// initial nodes
var nodes = d3.range(6).map(function(i) { 
		return {	
					radius: cellRadius(),
					x: width/2 + (Math.floor(Math.random()*10-5)),
					y: height/2 + (Math.floor(Math.random()*10-5)),
					index: i,
					color: getColor[i],
					children:[],
					parent:false,		// root, no parents
					alive: true,
					died: undefined,		// timestep
					born: 0,		// timestep
				}; 
	});


var force = d3.layout.force()
	.gravity(0.00)
// 	.charge(function(d, i) { return i ? 0 : -2000; })
	.charge(2000)
	.friction(0.2)
	.nodes(nodes)
	.size([width, height]);
 
force.start();

 

/* - - - - - - - - -  Zoom - - - - - - - - -  */

var zoom = d3.behavior.zoom()
	.scaleExtent([0.05, 10])	// 1=>100%
	.on("zoom", zoomed);		// register zoom event

function zoomed() {
	inner.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

var zooming = false;
var zoomBehaviour = function(scale) {
	// Clicks on the zoom buttons during zoom tweens are being ignored
	if (!zooming) {
		zooming = true;
		if (scale===0) {
			var t = {'start':zoom.translate(), 'end':[0,0]},
			s = {'start':zoom.scale(), 'end':1};
		} else {
			var t = {'start':zoom.translate(), 'end':[zoom.translate()[0]+(-scale*width/2), zoom.translate()[1]+(-scale*height/2)]},
			s = {'start':zoom.scale(), 'end':zoom.scale()+scale};
		}
		var it = d3.interpolate(t.start, t.end),
		is = d3.interpolate(s.start, s.end);
		d3.transition()
			.duration(750)
			.tween("zoom", function() {
				return function(tween) {
					inner.attr("transform", "translate(" + it(tween) + ")scale(" + is(tween) + ")");
				};
			})
			.each("end", function() {
				zoom.scale(s.end).translate(t.end);		// match object zoom settings with visual settings
				zooming = false;
			});
	}	
}

/* - - - - - - - - -  Zoom End - - - - - - - - -  */



	
var inner = d3.select("div#cells").append("svg")
		.attr("width", width)
		.attr("height", height)
		.call(zoom)
	.append("g")
 		.attr("id", "inner");
	

inner.selectAll("circle")
	.data(nodes)
	.enter()
		.append("circle")
			.attr("r", function(d) { return d.radius; })
			.attr("x", function(d) { return d.x; })
			.attr("y", function(d) { return d.y; })
			.attr("fill", function(d) { return d.color; });
/*
.transition()				
	.duration(function(d, i) { return 100*i})
*/
force.on("tick", function(e) {
	var q = d3.geom.quadtree(nodes),
	i = 0,
	n = nodes.length;
	while (++i < n) q.visit(collide(nodes[i]));
	inner.selectAll("circle")
		.attr("cx", function(d) { return d.x; })
		.attr("cy", function(d) { return d.y; });
});
 
/*
var dragging = false;
var circleElement;
svg.selectAll("circle").on("mousedown", function(circle) {
	console.log(circle);
	root = circle;
	root.fixed = true;
	root.color = this.style["fill"];				// temp save node color
	this.style["fill"] = "f00";						// highlight node	
	circleElement = this;							// save handler for circle svg	
	dragging = true;
});

svg.on("mousemove", function() {
	if (dragging) {
		var p1 = d3.mouse(this);
		root.px = p1[0];
		root.py = p1[1];
	}

});

svg.on("mouseup", function() {
	if (dragging) {
		dragging = false;
		delete root.fixed;
		circleElement.style["fill"] = root.color;		// restore color
		delete root.color;
		force.resume();
	}
});
*/

function collide(node) {

	var r = node.radius,	
	nx1 = node.x - 2*r,
	nx2 = node.x + 2*r,
	ny1 = node.y - 2*r,
	ny2 = node.y + 2*r;

	return function(quad, x1, y1, x2, y2) {
		if (quad.point && (quad.point !== node)) {
			var x = node.x - quad.point.x,
			y = node.y - quad.point.y,
			l = Math.sqrt(x * x + y * y),
			r = node.radius + quad.point.radius;
			if (l < r) {
				l = (l - r) / l * .5;
				node.x -= x *= l;
				node.y -= y *= l;
				quad.point.x += x;
				quad.point.y += y;
			}
		}
		return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
	};
}




// Interactions

var interpolateNodeSize = function(node, easeMode) {
	if (node.radius === node.finalRadius) return;
	var interpol = d3.interpolateNumber(node.radius, node.finalRadius);
	var ease= d3.ease(easeMode);
	var duration = 2000;
	var timer = d3.timer(function(t){
		if (t>duration) {
			node.radius = node.finalRadius;	// make sure the radius become the original radius
			return true; // true ends timer
		}
		node.radius = interpol(ease(t/duration));
	});	
}




var varyColor = function(c) {
	if (Math.random()*-0,5 > 0) {
		return d3.rgb(c).darker(0.2);
	} else {
		return d3.rgb(c).lighter(0.2);
	}
}

$(document).ready(function() {

	
	$("#addCell").click(function() {
		addSingleCell();
	});
	
	$("#addManyCells").click(function() {
		addCells(100);
	});
	
	$("#resetCells").click(function() {
		console.log("reset");
	});
	
	
	// Zoom Buttons
	$("#zoomIn").click(function() {
		zoomBehaviour(1);
	});
	
	$("#zoomOut").click(function() {
		zoomBehaviour(-1);
	});
	
	$("#zoomReset").click(function() {
		zoomBehaviour(0);
	});
});	

var currentTime = 1234;

var addSingleCell = function() {
	force.charge(0);	// neutralize force charge
	
	var parentNode = nodes[Math.floor(Math.random()*nodes.length)];		// get random node, plug-in Niida-code here...
	var randomAngle = Math.random()*Math.PI*2;							// in rad
	var x = Math.cos(randomAngle)*parentNode.radius + parentNode.x;
	var y = Math.sin(randomAngle)*parentNode.radius + parentNode.y;
	var childNode = {
		radius:0, 
		finalRadius:cellRadius(),
		color:varyColor(parentNode.color),
		x:x,
		y:y,
		angle:randomAngle,
		parent:parentNode,
		children:[],
		alive: true,
		died: undefined,		// timestep
		born: currentTime,		// current timestep
	}
	parentNode.children.push(childNode);
	nodes.push(childNode);					// add new node next to parent node, random angle
	
	
	
	
	circles = inner.selectAll("circle")			// select
		.data(nodes)							// rebind
	
	circles.enter()								// enter
		.append("circle")
			.attr("r", 0)									// initial radius
			.attr("x", function(n) { return n.x; })
			.attr("y", function(n) { return n.y; })
			.attr("fill", function(n, i) { return "#f00"; })		// highlight color
			.transition()
				.duration(2000)
				.ease("cubic-in-out")		// match with interpolateNodeSize()
				.attr("fill", function(n) {return n.color})
				.attr("r", function(n) { return n.finalRadius; })
				.each("start", function(n) { interpolateNodeSize(n, "cubic-in-out"); })

			;	// update visuals
			
	force.start();	
}

var addCells = function(nr) {
	var count = 0;
	var intervalID = window.setInterval(function() {
		count++;
		addSingleCell();
		if (count>=nr) {
			clearInterval(intervalID);
		}
	}, 200);	
}


// - - - - - - - - - - - - - - - - - - - - 



// B.E.P Simulation Mdeol
var id = 0;

var rootCells = [
{
	color: "#e41a1c",
	alive: true,
	died: undefined,		// timestep
	born: undefined,		// timestep
	parent: false,			// no parent, root cell
	children:[],			// pointers to children

}
]
var cellGraph = [].concat(rootCells);

/*
console.time("graph");
for (var i=0; i<1000000; i++) {
	var r = Math.floor(Math.random()*cellGraph.length);
	var oldCell = cellGraph[r];
	var newCell = Object.create(oldCell);
	newCell.id = id++;
	newCell.parent = oldCell;
	newCell.children = [];
	oldCell.children.push(newCell);
	cellGraph.push(newCell);
}
console.timeEnd("graph");

var mostChildren = 0;
var cellWithMostChildren;
console.time("find children");
for (var i=0; i<cellGraph.length; i++) {
	var c = cellGraph[i].children.length
	if (c > 0) {
		if (c > mostChildren) {
			mostChildren = c;
			cellWithMostChildren = cellGraph[i];
		//	console.log(i, "cellWithMostChildren", cellGraph[i].id);
		}
	//	console.log(i, cellGraph[i].children.length, cellGraph[i].children);
	}
}
console.timeEnd("find children");

var findRoot = function(id) {
	
	var cell = cellGraph[id];
	while (cell.parent) {
		console.log(cell.id);
		cell = cell.parent;
	}

	return "found";
}
*/

 
</script>