<!DOCTYPE html>
<head>
	<meta charset="utf-8">
	<title>BEP Force</title>
	<link rel="stylesheet" href="./css/bootstrap.css" charset="utf-8">
	<style type="text/css" media="screen">
		body {
			background: #eee;
			margin: 0 auto;
		}
		.container {
		 /* margin: 0 auto; */
		  width: 970px !important;
		}
		svg {
			background: #fff;
		}
		#settings {
			background: rgba(255,255,255,0.9);
			box-shadow: 5px 5px 10px #666666;
			display: none;
			position:absolute;
			width: 960px;
			z-index: 10;
			margin-left: 0px;
		}
	</style>
	
</head>

<body>
	
<div class="container">
	<div class="page-header">
	  <h1>B.E.P Simulator <small>Cancer-subtype Simulation</small></h1>
	</div>
	<div class="row">
		<div class="col-xs-4">
			<p>
				<button type="button" class="btn btn-default" id="settingsButton">Settings</button>
			</p>
		</div>
	</div>
	<div class="row" id="settings">
		
		<div class="col-xs-3">
			<p>
				Number of initial Cells: <span id="initialCellsNumber">6</span>
				<input name="initialCellsSlider" id="initialCellsSlider" type="range" min="1" max="9" value="6">
				<input name="initialCellsSlider" id="initialCellsSlider" type="number" min="1" max="9" value="6">
				
			</p>
			<p>
				maxPopulationSize: <span id="maxPopulationSize_label">300</span>	
				<input id="maxPopulationSize" type="range" min="100" max="5000" value="100">
			</p>
			<p>
				genomeSize: <span id="genomeSize_label">300</span>
				<input id="genomeSize" type="range" min="100" max="1000" value="300">
				
			</p>
			<p>
				driverSize: <span id="driverSize_label">10</span>
				<input id="driverSize" type="range" min="5" max="20" value="10">
			</p>
			
			
			
		</div>
		<div class="col-xs-3">Settings</div>
		<div class="col-xs-3">
			<p>
				mutationRate: <span id="mutationRate_label">0.1</span>
				<input id="mutationRate" type="range" min="0" max="100" value="10">
			</p>
			<p>
				growthRate: <span id="growthRate_label">0.1</span>
				<input id="growthRate" type="range" min="0" max="100" value="10">
			</p>
			<p>
				deathRate: <span id="deathRate_label">0.0000001</span>
				<input id="deathRate" type="range" min="1" max="1000" value="10">
			</p>
			<p>
				deathRateForNonStem: <span id="deathRateForNonStem_label">0.01</span>
				<input id="deathRateForNonStem" type="range" min="0" max="1000" value="10">
			</p>
		
		</div>
		<div class="col-xs-3">
			<p>
				symmetricReplicationP: <span id="symmetricReplicationProbablity_label">0.1</span>
				<input id="symmetricReplicationProbablity" type="range" min="0" max="1000" value="100">
			</p>
			
			<p>
				fitnessIncrease: <span id="fitnessIncrease_label">5</span>
				<input id="fitnessIncrease" type="range" min="1" max="20" value="5">
			</p>
			<p>
				essensialGeneSize: <span id="essensialGeneSize_label">0</span>
				<input id="essensialGeneSize" type="range" min="0" max="20" value="0">
			</p>	
			
		
			
			
		</div>
		
	</div>
	<div class="row">
		<div class="col-xs-2">
			
			<p>
				<div class="btn-group">
					<button type="button" class="btn btn-default btn-sm"id="playSimulation"><span class="glyphicon glyphicon-play"></span></button>
					<button type="button" class="btn btn-default btn-sm"id="pauseSimulation"><span class="glyphicon glyphicon-pause"></span></button>
					<button type="button" class="btn btn-default btn-sm"id="resetSimulation">Reset</span></button>
					<button type="button" class="btn btn-default btn-sm"id="getSimulationData">Get</span></button>
				</div>
				Generation <span class="badge" id="timeStep">0</span>
			</p>
			<p>
				<div class="btn-group">
					<button type="button" class="btn btn-default btn-xs"id="zoomIn"><span class="glyphicon glyphicon-zoom-in"></span></button>
					<button type="button" class="btn btn-default btn-xs"id="zoomOut"><span class="glyphicon glyphicon-zoom-out"></span></button>
					<button type="button" class="btn btn-default btn-xs"id="zoomReset"><span class="glyphicon glyphicon-search"></span></button>
				</div>
			</p>
			<p>
				<button type="button" class="btn btn-default" id="addCell">Add Cell</button>
			</p>
			<p>
				<button type="button" class="btn btn-default" id="addManyCells">Add 100 Cells</button>
			</p>
			
		
		</div>
		<div class="col-xs-10" id="cells"></div>
	</div>
</div>
<script src="./js/d3.min.js"></script>
<script src="./js/queue.min.js"></script>
<script src="./js/jquery-2.0.3.min.js"></script>
<script src="./js/colorbrewer.js"></script>
<script>

// https://gist.github.com/mbostock/3231307

var width = 800,
    height = 500;

/* - - - - - - - - -  Settings - - - - - - - - -  */
var settings = {
	n: 100,				// number of genes
//	g: ,				// genome, length n
	p0: 0.001,			// initial replication probability
	q0: 0.0000001,		// death probabiliy
	r: 0.01, 			// mutation probabiliy of each gene when replicated
	d: 10, 				// number of driver genes, first d genes of g
	maxNumberOfCells: 100000,
	initialCells: 6,
};
/* - - - - - - - - -  Settings End - - - - - - - - -  */



/* - - - - - - - - -  Color - - - - - - - - -  */

var initColor = function() {
	return colorbrewer.Set1[9];		//  from Colorbrewer 1-9 colors...
//	return colorbrewer.Set3[12];		//  from Colorbrewer 1-9 colors...
	
}
var getColor = initColor();

/* - - - - - - - - -  Color End - - - - - - - - -  */







var cells = [];			// displayed cells
var cachedCells = []	// chached cells from webworker

var force = d3.layout.force()
	.gravity(0.00)
	.charge(2000)
	.friction(0.2)
	.nodes(cells)
	.size([width, height])
	.start();
	


/* - - - - - - - - -  Zoom - - - - - - - - -  */

var zoom = d3.behavior.zoom()
	.scaleExtent([0.05, 10])	// 1=>100%
	.on("zoom", zoomed);		// register zoom event

function zoomed() {
	inner.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

var zooming = false;
var zoomBehaviour = function(scale) {
	// Clicks on the zoom buttons during zoom tweens are being ignored
	if (!zooming) {
		zooming = true;
		if (scale===0) {
			var t = {'start':zoom.translate(), 'end':[0,0]},
			s = {'start':zoom.scale(), 'end':1};
		} else {
			var t = {'start':zoom.translate(), 'end':[zoom.translate()[0]+(-scale*width/2), zoom.translate()[1]+(-scale*height/2)]},
			s = {'start':zoom.scale(), 'end':zoom.scale()+scale};
		}
		var it = d3.interpolate(t.start, t.end),
		is = d3.interpolate(s.start, s.end);
		d3.transition()
			.duration(750)
			.tween("zoom", function() {
				return function(tween) {
					inner.attr("transform", "translate(" + it(tween) + ")scale(" + is(tween) + ")");
				};
			})
			.each("end", function() {
				zoom.scale(s.end).translate(t.end);		// match object zoom settings with visual settings
				zooming = false;
			});
	}	
}

/* - - - - - - - - -  Zoom End - - - - - - - - -  */



	
var inner = d3.select("div#cells").append("svg")
		.attr("width", width)
		.attr("height", height)
		.call(zoom)
	.append("g")
 		.attr("id", "inner");
	

inner.selectAll("circle")
	.data(cells, function(n) { return n.index; })			// join node data with index
	.enter()
		.append("circle")
			.attr("r", function(d) { return d.radius; })
			.attr("x", function(d) { return d.x; })
			.attr("y", function(d) { return d.y; })
			.attr("fill", function(d) { return d.color; });


force.on("tick", function(e) {
	var q = d3.geom.quadtree(cells),
	i = 0,
	n = cells.length;
	// while (++i < n) q.visit(collide(cells[i]));
	for(i=0;i<n;i++) {
		q.visit(collide(cells[i]));
	}
	inner.selectAll("circle")
		.attr("cx", function(n) { return n.x; })
		.attr("cy", function(n) { return n.y; });
});
 
/*
var dragging = false;
var circleElement;
svg.selectAll("circle").on("mousedown", function(circle) {
	console.log(circle);
	root = circle;
	root.fixed = true;
	root.color = this.style["fill"];				// temp save node color
	this.style["fill"] = "f00";						// highlight node	
	circleElement = this;							// save handler for circle svg	
	dragging = true;
});

svg.on("mousemove", function() {
	if (dragging) {
		var p1 = d3.mouse(this);
		root.px = p1[0];
		root.py = p1[1];
	}

});

svg.on("mouseup", function() {
	if (dragging) {
		dragging = false;
		delete root.fixed;
		circleElement.style["fill"] = root.color;		// restore color
		delete root.color;
		force.resume();
	}
});
*/

function collide(node) {

	var r = node.radius,	
	nx1 = node.x - 2*r,
	nx2 = node.x + 2*r,
	ny1 = node.y - 2*r,
	ny2 = node.y + 2*r;

	return function(quad, x1, y1, x2, y2) {
		if (quad.point && (quad.point !== node)) {
			var x = node.x - quad.point.x,
			y = node.y - quad.point.y,
			l = Math.sqrt(x * x + y * y),
			r = node.radius + quad.point.radius;
			if (l < r) {
				l = (l - r) / l * .5;
				node.x -= x *= l;
				node.y -= y *= l;
				quad.point.x += x;
				quad.point.y += y;
			}
		}
		return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
	};
}




// Interactions

var interpolateNodeSize = function(node, easeMode) {
	if (node.radius === node.finalRadius) return;
	var interpol = d3.interpolateNumber(node.radius, node.finalRadius);
	var ease= d3.ease(easeMode);
	var duration = 1000;
	var timer = d3.timer(function(t){
		if (t>duration) {
			node.radius = node.finalRadius;		// make sure the radius become the original radius
			delete node.finalRadius;			// remove finalRadius property
			return true; // true ends timer
		}
		node.radius = interpol(ease(t/duration));
	});	
}




var varyColor = function(color) {
	if (Math.random()*-0,5 > 0) {
		return color.darker(0.1);
	} else {
		return color.lighter(0.1);
	}
}

$(document).ready(function() {


	$("#playSimulation").click(function() {
		console.log("play");
		worker.postMessage(JSON.stringify({'message':'startSimulation', 'settings':settings, 'cells':cells}));
		
	});
	
	$("#pauseSimulation").click(function() {
		console.log("pause");
	});
	
	$("#resetSimulation").click(function() {
		console.log("reset");
	});
	
	$("#getSimulationData").click(function() {
		worker.postMessage(JSON.stringify({'message':'get', 'start':0, 'end':1000}));
	});
	
	$("#addCell").click(function() {
		addCell();
	});
	
	$("#addManyCells").click(function() {

	});
	
	$("#resetCells").on('click', function() {
		console.log("reset");
	});
	
	$("#initialCellsSlider").on('change', function(e) {
		var n = this.value;
		$('#initialCellsNumber').html(n);		// update number display
		settings.initialCells = n;						// update settings
		
		var diff = n - cells.length;
		console.log("diff", diff);
		if (diff>0) addCell(diff);
		if (diff<0) removeCell(diff);

		
	});
	
	
	
	// Zoom Buttons
	$("#zoomIn").click(function() {
		zoomBehaviour(1);
	});
	
	$("#zoomOut").click(function() {
		zoomBehaviour(-1);
	});
	
	$("#zoomReset").click(function() {
		zoomBehaviour(0);
	});
	
	
	$("#settingsButton").click(function() {
		if ($("#settings").is( ":hidden" )) {
			$("#settings").slideDown();
		} else {
			$("#settings").slideUp();
		}
		
	});
	
	
	
	
});	




var updateNodeDisplay = function(n) {
	
	force.charge(0);
	
	var delay = 0;
	
	circles = inner.selectAll("circle")						// select
		.data(cells, function(n){ return n.index; } );		// rebind with key
	
	circles.enter()											// enter
		.append("circle")
			.attr("r", 0)									// initial radius
			.attr("x", function(n) { return n.x; })
			.attr("y", function(n,i) { return n.y; })
			.attr("fill", function(n) {return n.color})
			.transition()
				.duration(1000)
			//	.delay(function() { var d = delay; delay += 100; return d})
				.ease("cubic-in-out")		// match with interpolateNodeSize()
				.attr("r", function(n) { return n.finalRadius; })
				.each("start", function(n) { interpolateNodeSize(n, "cubic-in-out"); })
			;	// update visuals

	circles.exit()								// exit
		.attr("r", function(n) { return n.radius; })
		.transition()
			.duration(1000)
		//	.delay(function() { var d = delay; delay += 200; return d})
			.ease("cubic-in-out")		// match with interpolateNodeSize()
			.attr("r", function(n) { return 0; })
			.each("end", function(n) { 
				interpolateNodeSize(n, "cubic-in-out");
				console.log("end"); 
				})
		.remove();
	

	force.start();
	
	
	
}



/* - - - - - - - - - Worker - - - - - - - - - */


var worker = new Worker("./js/worker.js");			// init

worker.onmessage = function(e) {
	var data = JSON.parse(e.data);
	console.log("from worker, data.message: ", data, data.message);
	
	if (data.message==='firstCells') {
		console.log("worker response: firstCells", data);
		
		cachedCells = data.cells;
		
		/*
		getColor = initColor(cachedCells.length);		// update color scheme
		for (var i=0; i<cachedCells.length; i++) {
			cachedCells[i].color = getColor[i];			// asign  colors
			cachedCells[i].x = width/2 + (Math.floor(Math.random()*10-5));
			cachedCells[i].y = height/2 + (Math.floor(Math.random()*10-5));
		}
		*/
				
		// addInitialCells();
	}
	
	if (data.message==='allCells') {
		allCells = data.cells;
	}
	
}



/* - - - - - - - - - Worker End - - - - - - - - - */



/* - - - - - - - - - Create Inital Cells - - - - - - - - - */

// Single Inital Cell Object
var Cell = function() {
	var i = cells.length;
	this.index = i;				// append to cells array
	this.radius = 0;			// important to set initial radius to 0
	this.finalRadius = Math.floor(Math.random() * 5 + 10);
	this.children = [];
	this.parent = false;	// root, no parents
	this.alive = true;
	this.died = undefined;						// timestep
	this.born = 0;								// timestep, start, 0
	this.randomAngle = Math.random()*Math.PI*2;
	this.color = getColor[i];
	this.x = width/2 + (Math.floor(Math.random()*20-10));
	this.y = height/2 + (Math.floor(Math.random()*20-10));
	this.driverGenes = d3.range(settings.d).map(function() { return false; });			// false -> not mutated
	this.genes = d3.range(settings.n-settings.d).map(function() { return false; });		// false -> not mutated
	if (i>0) {
		var parentCell = cells[Math.floor(Math.random()*i)];
		this.x = Math.cos(this.randomAngle)*parentCell.radius + parentCell.x;
		this.y = Math.sin(this.randomAngle)*parentCell.radius + parentCell.y;		
	}
	return this;
}

var addCell = function(nr) {
	if (nr===undefined) nr = 1;
	for(var i=0; i<nr; i++) {
		cells.push(new Cell());
	}
	updateNodeDisplay();
}

var removeCell = function(nr) {
	if (nr===undefined) nr = 1;
	for(var i=0; i<Math.abs(nr); i++) {
		cells.pop();
	}
	updateNodeDisplay();
}

var addInitialCells = function(nr) {
	var intervalID = window.setInterval(function() {
		addCell();
		if (cells.length>=settings.initialCells) clearInterval(intervalID);
	}, 200);	
}();	// execute immeditaly

var addAdditionalCells = function(nr) {
	if (nr===undefined) nr = 1;
	
	force.charge(0); // neutralize force
	
	console.log("addAdditionalCells", nr, cells.length);
	var intervalID = window.setInterval(function() {
	//	console.log("addAdditionalCells", nr, cells.length);	
			
			var cell = cachedCells[cells.length];
			var parentCell = cells[cell.parent]
			cell.color = varyColor(d3.rgb(parentCell.color));
			cell.x = Math.cos(cell.randomAngle)*parentCell.radius + parentCell.x;
			cell.y = Math.sin(cell.randomAngle)*parentCell.radius + parentCell.y;
			cells.push(cell);
			
			// update generation
			$('#timeStep').text(cell.born);
			updateNodeDisplay();
		
		
		if (cells.length>=nr) clearInterval(intervalID);
		
	}, 200);
}


/* - - - - - - - - - Create Inital Cells  End - - - - - - - - - */


 
</script>