<!DOCTYPE html>
<head>
	<meta charset="utf-8">
	<title>BEP Force</title>
	<link rel="stylesheet" href="./css/bootstrap.css" charset="utf-8">
	<style type="text/css" media="screen">
		body {
			background: #eee;
			margin: 0 auto;
		}
		.container {
		 /* margin: 0 auto; */
		  width: 970px !important;
		}
		svg {
			background: #fff;
			width: 100%;
		}
		#stream svg {
			height: 100px;
		}
		#settings {
		/*	background: #6cf; */
			display: none;
		}
		.dropdown-menu-settings {
			width: 695px;
			background: rgba(255,255,255,0.9);
			padding: 0px;
		}
		.dropdown-menu-settings .settings-unit {
			margin-bottom: 20px;

		}
		.dropdown-menu-settings .settings-column {
			width: 220px;
			float: left;
			margin-right: 10px;
			padding: 10px;
		}
		
		.dropdown-menu-settings .settings-value {
			font-size: 2em;
			line-height: 1em;
			color: #00f;
		}
		
		.dropdown-menu-settings input {
			width: 100%;
		}
		
		line.link {
			stroke: #555;
			stroke-linecap: round;
			stroke-width: 2;
			stroke-opacity: 1;
			pointer-events: none;
			marker-end: url(#Arrow);
		}
		
	</style>
	
</head>

<body>
	
<div class="container">
	<div class="page-header">
	  <h1>B.E.P Simulator <small>Cancer-subtype Simulation</small></h1>
	</div>
	<nav class="navbar navbar-default" role="navigation">
		<ul class="nav navbar-nav">
			<li class="dropdown">
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Settings <b class="caret"></b></a>
				<ul class="dropdown-menu dropdown-menu-settings">
					<div class="settings-column">
						<div class="settings-unit">
							<div class="settings-value" id="initialCellsNumber">6</div>
							<div>Number of Initial Cells</div>
							<input id="initialCellsSlider" type="range" min="1" max="9" value="6">
						</div>
						<div class="settings-unit">
							<div class="settings-value" id="maxPopulationSize_label">1000</div>	
							<div>Max. Population Size</div>
							<input id="maxPopulationSize" type="range" min="100" max="1000000" value="1000">
						</div>	
						<div class="settings-unit">
							<div class="settings-value" id="genomeSize_label">300</div>	
							<div>Genes</div>
							<input id="genomeSize" type="range" min="100" max="1000" value="300">
						</div>	
						<div class="settings-unit">
							<div class="settings-value" id="driverSize_label">10</div>	
							<div>Driver Genes</div>
							<input id="driverSize" type="range" min="5" max="20" value="10">
						</div>	
					</div>
			
					<div class="settings-column">
						<div class="settings-unit">
							<div class="settings-value" id="mutationRate_label">0.1</div>
							<div>Mutation Rate</div>
							<input id="mutationRate" type="range" min="0" max="100" value="10" data-min="0" data-max="0.5" data-value="0.1">
						</div>
						<div class="settings-unit">
							<div class="settings-value" id="growthRate_label">0.1</div>	
							<div>Growth Rate</div>
							<input id="growthRate" type="range" min="0" max="100" value="10" data-min="0" data-max="0.5" data-value="0.1">
						</div>	
						<div class="settings-unit">
							<div class="settings-value" id="deathRate_label">0.0000001</div>	
							<div>Death Rate for Stem Cells</div>
							<input id="deathRate" type="range" min="0" max="100" value="10" data-min="0" data-max="0.000001" data-value="0.0000001">
						</div>	
						<div class="settings-unit">
							<div class="settings-value" id="deathRateForNonStem_label">0.01</div>	
							<div>Death Rate for Non-stem Cells</div>
							<input id="deathRateForNonStem" type="range" min="0" max="100" value="10" data-min="0" data-max="0.5" data-value="0.1">
						</div>	
					</div>
								
					<div class="settings-column">
						<div class="settings-unit">
							<div class="settings-value" id="srp_label">0.5</div>
							<div>Symmetric Repl. Probability</div>
							<input id="srp" type="range" min="0" max="100" value="50" data-min="0" data-max="1" data-value="0.5">
						</div>
						<div class="settings-unit">
							<div class="settings-value" id="fitnessIncrease_label">5</div>	
							<div>Fitness Increase</div>
							<input id="fitnessIncrease" type="range" min="1" max="20" value="5">
						</div>	
						<div class="settings-unit">
							<div class="settings-value" id="essensialGeneSize_label">0</div>	
							<div>Essensial Gene Size</div>
							<input id="essensialGeneSize" type="range" min="0" max="20" value="0">
						</div>	
					
						<div class="settings-unit">
							<div class="navbar-right">
								<button type="button" class="btn btn-default" id="resetSettings">Reset</span></button>
								<button type="button" class="btn btn-default" id="saveSettings">Save</span></button>
							</div>
						</div>
						
					</div>
				
						
					
				
					
					
				</ul>
			</li>

			<li class="dropdown">
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Help <b class="caret"></b></a>
				<ul class="dropdown-menu">
					<li><a href="#">Action</a></li>
					<li><a href="#">Another action</a></li>
					<li><a href="#">Something else here</a></li>
					<li class="divider"></li>
					<li><a href="#">Separated link</a></li>
					<li class="divider"></li>
					<li><a href="#">One more separated link</a></li>
				</ul>
			</li>
		</ul>
	  	<form class="navbar-form navbar-left">
			<div class="btn-group">
				<button type="button" class="btn btn-default" id="startPauseSimulation"><span class="glyphicon glyphicon-play"></span></button>
				<button type="button" class="btn btn-default" id="resetSimulation">Reset</span></button>
			</div>
		</form>
		<p class="navbar-text">
			Time <span class="badge" id="timeLabel">0</span>
		</p>
		<p class="navbar-text">
			Cells <span class="badge" id="cellLabel">0</span>
		</p>
		<p class="navbar-text">
			<select class="form-control  input-sm" id="stream_select">
				<option value="silhouette">Silhouette</option>
				<option value="wiggle">Wiggle</option>
				<option value="expand">Expand</option>
				<option value="zero">Zero</option>
			</select>
		</p>
		<form class="navbar-form navbar-right">
			<div class="btn-group">
				<button type="button" class="btn btn-default" id="zoomIn"><span class="glyphicon glyphicon-zoom-in"></span></button>
				<button type="button" class="btn btn-default" id="zoomOut"><span class="glyphicon glyphicon-zoom-out"></span></button>
				<button type="button" class="btn btn-default" id="zoomReset"><span class="glyphicon glyphicon-search"></span></button>
			</div>
		</form>
		<p class="navbar-text navbar-right">
			Zoom <span class="badge" id="zoomLabel">1.0</span>
		</p>


	</nav>
	

	<div class="row" id="settings">
		
	
		
		<div class="col-xs-3">
			<p>
				symmetricReplicationP: <span id="srp_label">0.1</span>
				<input id="srp" type="range" min="0" max="1000" value="100">
			</p>
			
			<p>
				fitnessIncrease: <span id="fitnessIncrease_label">5</span>
				<input id="fitnessIncrease" type="range" min="1" max="20" value="5">
			</p>
			<p>
				essensialGeneSize: <span id="essensialGeneSize_label">0</span>
				<input id="essensialGeneSize" type="range" min="0" max="20" value="0">
			</p>	
			
		
			
			
		</div>
		
	</div>
	
	<div class="row">
		<div class="col-xs-12" id="stream">
			<svg>
			</svg>
		</div>
	</div>

	<div class="row">
		<div class="col-xs-12" id="cells">
			<svg>
				<defs>
					<marker id="Arrow" viewBox="0 0 10 10" refX="1" refY="5" markerWidth="6" markerHeight="6" orient="auto">
						<path d="M 0 0 L 10 5 L 0 10 z" />
					</marker>
				</defs>
			</svg>
		</div>
	</div>
</div>
<script src="./js/d3.min.js"></script>
<script src="./js/jquery-2.0.3.min.js"></script>
<script src="./js/science.v1.min.js"></script>
<script src="./js/numeric-1.2.6.min.js"></script>
<script src="./js/colorbrewer.js"></script>
<script src="./js/bootstrap.min.js"></script>

<script>

// https://gist.github.com/mbostock/3231307

var width = 960,
    height = 500;


/* - - - - - - - - -  Settings - - - - - - - - -  */
// Define or get from local storage


var getSettings = function() {
	var settings;
	if (window.localStorage && window.localStorage.bepSettings) {
		console.log("Reading settings from cache");
		settings = JSON.parse(window.localStorage.bepSettings);
		console.log("Updating Display");
		
		$('#initialCellsNumber').html(settings.initialCells);
		$('#mutationRate_label').html(settings.mutationRate);
		$('#growthRate_label').html(settings.growthRate);
		$('#deathRate_label').html(settings.deathRate);
		$('#deathRateForNonStem_label').html(settings.deathRateForNonStem);
		$('#srp_label').html(settings.srp);
		$('#maxPopulationSize_label').html(settings.maxNumberOfCells);
		$('#genomeSize_label').html(settings.n);
		$('#driverSize_label').html(settings.d);
		$('#essensialGeneSize_label').html(settings.d);
		$('#fitnessIncrease_label').html(settings.fitnessIncrease);		
		
	} else {
		settings = {
			n: 100,						// number of genes
			d: 10, 						// number of driver genes, first d genes of g
			e: 5,						// number of essential genes 
			mutationRate: 0.01,			// mutation probabiliy of each gene when replicated
			growthRate: 0.01,			// 0.0001
			deathRate: 0.0001,		
			deathRateForNonStem: 0.01,
			srp: 0.1,	//s ymmetricReplicationProbablity
			fitnessIncrease: 5, 
			maxNumberOfCells: 10000,
			initialCells: 6,
		};
	}
	return settings;
}

settings = getSettings();


/* - - - - - - - - -  Settings End - - - - - - - - -  */



/* - - - - - - - - -  Color - - - - - - - - -  */

/* Create Array of string colors, declare function & execute once */
var getColor = function() {
	return colorbrewer.Set1[9].map(function(c){ return c; });
//	return colorbrewer.Set3[12].map(function(c){ return c; });
}();

/* - - - - - - - - -  Color End - - - - - - - - -  */







var cells = [];			// displayed cells
var cachedCells = []	// chached cells from webworker

var force = d3.layout.force()
	.size([width, height])
	.gravity(0.00)
	.charge(100)
//	.chargeDistance
	.friction(0.2)
	.nodes(cells, function(n){ return n.id})
	.linkDistance(10)			// default 20
	.linkStrength(0)			// [0,1] default 1
	.start();
	
	
var tree = d3.layout.tree()
	.size([width, height])
	
var tempChildren = [];
var updateTree = function() {
	cells.forEach(function(n){
		var a = n.children.map(function(childID){
			tempChildren.push(childID);
			return cachedCells[childID];
			
		});
		n.children = a;
	})
	tree.nodes(cells);
	tempChildren.sort(function(a,b){ return a-b });
}
	

/* - - - - - - - - -  Zoom - - - - - - - - -  */


var zoom = d3.behavior.zoom()
	.scaleExtent([0.05, 10])	// 1=>100%
	.on("zoom", zoomed);		// register zoom event

function zoomed() {
	$("#zoomLabel").text(zoom.scale().toPrecision(2));
	inner.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}


var zooming = false;

var zoomBehaviour = function(scale) {
	var s, t, it, is, z;
	console.log(scale);
//	$("#zoomLabel").text(zoom.scale());
	
	// Clicks on the zoom buttons during zoom tweens are being ignored
	if (!zooming) {
		zooming = true;
		if (scale==='reset') {	// zoom reset
			t = {'start':zoom.translate(), 'end':[0,0]},
			s = {'start':zoom.scale(), 'end':1};
		} else if (scale==='in') {
			// 1
			z = zoom.scale()*2;
			t = {'start':zoom.translate(), 'end':[zoom.translate()[0]+(-zoom.scale()*width/2), zoom.translate()[1]+(-zoom.scale()*height/2)] },
			s = {'start':zoom.scale(), 'end':z};
		} else if (scale==='out') {
			z = zoom.scale()/2;
			t = {'start':zoom.translate(), 'end':[zoom.translate()[0]+(z*width/2), zoom.translate()[1]+(z*height/2)] },
			s = {'start':zoom.scale(), 'end':z};
		}
		it = d3.interpolate(t.start, t.end),
		is = d3.interpolate(s.start, s.end);
		d3.transition()
			.duration(750)
			.tween("zoom", function() {
				return function(tween) {
					inner.attr("transform", "translate(" + it(tween) + ")scale(" + is(tween) + ")");
				};
			})
			.each("end", function() {
				zoom.scale(s.end).translate(t.end);		// match object zoom settings with visual settings
				zooming = false;
				$("#zoomLabel").text(zoom.scale().toPrecision(2));
			});
	}	
}

/* - - - - - - - - -  Zoom End - - - - - - - - -  */


var inner = d3.select("div#cells svg")
		.attr("width", width)
		.attr("height", height)
		.attr("id", "forceCells")
		.call(zoom)
	.append("g")
 		.attr("id", "inner");
	
var cellGroup = inner.append("g").attr("id", "cellGroup");
var linkGroup = inner.append("g").attr("id", "linkGroup");

var circles = cellGroup.selectAll("circle")
	.data(cells, function(n) { return n.id; })			// join node data with id
	.enter().append("circle")
		.attr("r", function(d) { return d.radius; })
		.attr("x", function(d) { return d.x; })
		.attr("y", function(d) { return d.y; })
		.attr("fill", function(d) { return d.color; });







force.on("tick", function(e) {
	var q = d3.geom.quadtree(cells),
	i = 0,
	n = cells.length;
	while (++i < n) q.visit(collide(cells[i]));
	updateCellPosition();
});
 
var updateCellPosition = function() {
	// nodes
	circles
		.attr("cx", function(n) { return n.x; })
		.attr("cy", function(n) { return n.y; });
		
	// links
	if (force.links().length > 0) {
		link
			.attr("x1", function(d) { return d.source.x; })
			.attr("y1", function(d) { return d.source.y; })
			.attr("x2", function(d) { return d.target.x; })
			.attr("y2", function(d) { return d.target.y; })
	}
}




	
	
/*

// var dragging = false;
// var circleElement;
inner.on("mousedown", function(c) {
	root = circle;
	root.fixed = true;
	root.color = this.style["fill"];				// temp save node color
	this.style["fill"] = "f00";						// highlight node	
	circleElement = this;							// save handler for circle svg	
	dragging = true;
	
});



svg.on("mousemove", function() {
	if (dragging) {
		var p1 = d3.mouse(this);
		root.px = p1[0];
		root.py = p1[1];
	}

});

svg.on("mouseup", function() {
	if (dragging) {
		dragging = false;
		delete root.fixed;
		circleElement.style["fill"] = root.color;		// restore color
		delete root.color;
		force.resume();
	}
});
*/

function collide(node) {

	var r = node.radius,	
	nx1 = node.x - 2*r,
	nx2 = node.x + 2*r,
	ny1 = node.y - 2*r,
	ny2 = node.y + 2*r;

	return function(quad, x1, y1, x2, y2) {
		if (quad.point && (quad.point !== node)) {
			var x = node.x - quad.point.x,
			y = node.y - quad.point.y,
			l = Math.sqrt(x * x + y * y),
			r = node.radius + quad.point.radius;
			if (l < r) {
				l = (l - r) / l * .5;
				node.x -= x *= l;
				node.y -= y *= l;
				quad.point.x += x;
				quad.point.y += y;
			}
		}
		return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
	};
}




// Interactions

var interpolateNodeSize = function(node) {	
	var easeMode = "cubic-in-out";
	if (node.radius === node.finalRadius) return;
	var interpol = d3.interpolateNumber(node.radius, node.finalRadius);
	var ease= d3.ease(easeMode);
	var duration = 1000;
	var timer = d3.timer(function(t){
		if (t>duration) {
			node.radius = node.finalRadius;		// make sure the radius become the original radius
			delete node.finalRadius;			// remove finalRadius property
			return true; // true ends timer
		}
		node.radius = interpol(ease(t/duration));
	});	
}

var varyColor = function(stringColor) {
	var color = d3.rgb(stringColor);
	if (Math.random() > 0.5) {
		return color.darker(Math.random()/3).toString();		// return hex color, NOT d3.rgb object
	} else {
		return color.brighter(Math.random()/3).toString();
	}
}

var simulating = false;
var simulationFinished = false;
$(document).ready(function() {

	$("#startPauseSimulation").click(function() {
		if (simulationFinished) {
			addAdditionalCells(cells.length + 100);
		} else if (simulating) {
			simulating = false
			$(this).html('<span class="glyphicon glyphicon-play"></span>');
			
		} else {
			simulating = true
			$(this).html('<span class="glyphicon glyphicon-pause"></span>');
			worker.postMessage(JSON.stringify({'message':'startSimulation', 'settings':settings, 'cells':cells}));
			console.time("Simulation");
		}
	});

	$("#resetSimulation").click(function() {
		console.log("reset");
	});

	

	
	// preventing settings dropdown to hide when slider are changed
	$(".dropdown-menu-settings").on('click', function(e) {
		e.stopPropagation();
	});
	
	
	// Zoom Buttons
	$("#zoomIn").click(function() {
		zoomBehaviour('in');
	});
	
	$("#zoomOut").click(function() {
		zoomBehaviour('out');
	});
	
	$("#zoomReset").click(function() {
		zoomBehaviour('reset');
	});
	
	// Settings
	
	$("#initialCellsSlider").on('change', function(e) {
		var n = parseInt(this.value);
		$('#initialCellsNumber').html(n);		// update number display
		settings.initialCells = n;						// update settings
		var diff = n - cells.length;
		if (diff>0) addCell(diff);
		if (diff<0) removeCell(diff);
	});
	
	$("#mutationRate").on("change", function() {
		updateSettings(this, "mutationRate", "mutationRate_label", "mutationRate", "mutationRate");
	});
	
	$("#growthRate").on("change", function() {
		updateSettings(this, "growthRate", "growthRate_label", "growthRate");
	});
	
	$("#deathRate").on("change", function() {
		updateSettings(this, "deathRate", "deathRate_label", "deathRate");
	});
	
	$("#deathRateForNonStem").on("change", function() {
		updateSettings(this, "deathRateForNonStem", "deathRateForNonStem_label", "deathRateForNonStem");
	});
	
	$("#srp").on("change", function() {
		updateSettings(this, "srp", "srp_label", "srp");
	});
	
	/*
	$("#maxTime").on("change", function() {
		updateField("maxTime", this.value);
	});
	*/
	
	$("#maxPopulationSize").on("change", function() {
		updateSettings(this, "maxPopulationSize", "maxPopulationSize_label", "maxNumberOfCells");
	});
	
	$("#genomeSize").on("change", function() {
		updateSettings(this, "genomeSize", "genomeSize_label", "n");
	});
	
	$("#driverSize").on("change", function() {
		updateSettings(this, "driverSize", "driverSize_label", "d");
	});
	
	$("#essensialGeneSize").on("change", function() {
		updateSettings(this, "essensialGeneSize", "essensialGeneSize_label", "essentialGeneSize");
	});
	
	$("#fitnessIncrease").on("change", function() {
		updateSettings(this, "fitnessIncrease", "fitnessIncrease_label", "fitnessIncrease");
	});
	
	$("#stream_select").on("change", function(e) {
		streamType = $(this).val();
		updateStreamData();
	});	
	
	
	circles.on("mousedown", function(c) {
		console.log(c);
	})
});	


var updateSettings = function(that, key, label, settingName) {
	var s = $(that);
	var sliderMin = s.attr('min');
	var sliderMax = s.attr('max');
	var value = s.val();
	var displayValue = value;
		
	if (s.data('min')!==undefined && s.data('max')!==undefined) {		// transpose
		var scale = d3.scale.linear()
						.domain([sliderMin, sliderMax])
						.range([s.data('min'), s.data('max')]);
		value = scale(value);
		displayValue = value.toPrecision(2);
	}

	console.log(value);
	settings[settingName] = parseFloat(value);						// update settings
	$("#"+key+"_label").html(displayValue);							// update display
	if (window.localStorage) {										// update cache
		window.localStorage.bepSettings = JSON.stringify(settings);
	}
}

var getInfo = function() {
	for (var i=0; i<cells.length; i++) {
		console.log(i, cells[i].id, cells[i]);
	}
}

var updateNodeDisplay = function(n) {
	
	force.charge(0);
	
	circles = cellGroup.selectAll("circle")						// select
		.data(cells, function(n) { return n.id; } );		// rebind with key

	force.nodes(cells, function(n) { return n.id; } );			// rebind new cells with force layout
	
	// create new link map
	links = [];
	cells.map(function(cell) {
		var ancestor = findAncestor(cell);									// get ancestor cell from cached cells
		if (ancestor !== false) {										// check if ancestor exists
			if (cell.alive && ancestor.alive) {						// check if cell and parent are alive
				links.push({'source': ancestor, 'target': cell});		// create link with objects
			}
		}
	});
	
	
	force.links(links, function(d,i) { i + "-" + d.source.id + "-" + d.target.id; });
	force.start();
	
	circles.enter()											// enter
		.append("circle")
			.attr("r", 0)									// initial radius
			.attr("x", function(n) { return n.x; })
			.attr("y", function(n) { return n.y; })
			.attr("fill", function(n) {return n.color})
			.transition()
				.duration(1000)
				.ease("cubic-in-out")		// match with interpolateNodeSize()
				.attr("r", function(n) { return n.finalRadius; })
				.each("start", function(n) { interpolateNodeSize(n); })
			;	// update visuals
	
	//circles.exit().remove();
		
	circles.exit()
		.transition()
			.duration(199)				// match with delay time at adding cells..., or remove transition completely
			.ease("cubic-in-out")
			.attr("r", 0)
		.remove();
	
	

	link = linkGroup.selectAll("line.link")		
		.data(links, function(d, i) { 
			var unique = i + "-" + d.source.id + "-" + d.target.id;
			return  unique; 
		});

	link.enter()
		.append("line").attr("class", "link")
		.attr("opacity", 0)
		.attr("line-width", 0)
		.transition()
			.duration(800)
			.attr("opacity", 1)
			.attr("line-width", 2)
	
	link.exit().remove();			// remove when they no longer exist
	
	
			
	
	$("#cellLabel").text(cells.length);
	$("#timeLabel").text(cells[cells.length-1].born);
	
}


// find closed ancestor of a cell. in cases when the parent died, create link to ancestor.
var findAncestor = function(cell) {
	var parentID = cell.parent;
	while (parentID !== false) {
		var ancestor = cachedCells[parentID];
		if (ancestor.alive) {
			return ancestor;
		}
		parentID = ancestor.parent
	}	
	return false;
}




/* - - - - - - - - - Worker - - - - - - - - - */


var workerURL = "./js/worker.js?" + Math.floor(Math.random()*1000000);	// prevent worker caching
var worker = new Worker(workerURL);			// init

worker.onmessage = function(e) {
	var data = JSON.parse(e.data);
//	console.log("from worker, data.message: ", data, data.message);
	
	if (data.message==='simulationFinished') {
		console.log("simulationFinished");
		cachedCells = data.cells;
		cells = cachedCells.slice(0, settings.initialCells);		// update inital cells with mutations, time of death, etc
		info = data.info;
		console.log(cachedCells.length, info);
		addAdditionalCells(20);
	}
	
}




/* - - - - - - - - - Worker End - - - - - - - - - */



/* - - - - - - - - - Create Inital Cells - - - - - - - - - */

// Single Inital Cell Object
var Cell = function() {
	var i = cells.length;
	this.id = i;				// append to cells array
	this.isStem = true;		// stem or normal... stem -> stem|normal, normal -> normal
	this.subtype = i;			// initial subtypes
	this.radius = 0;			// important to set initial radius to 0
// 	this.finalRadius = Math.floor(Math.random() * 5 + 10);
	this.finalRadius = 12;
	this.children = [];
	this.parent = false;	// root, no parents
	this.alive = true;
	this.died = undefined;						// timestep
	this.born = 0;								// timestep, start, 0
	this.randomAngle = Math.random()*Math.PI*2;
	this.color = getColor[i];
	this.x = width/2 + (Math.floor(Math.random()*20-10));
	this.y = height/2 + (Math.floor(Math.random()*20-10));
	this.driverGenes = d3.range(settings.d).map(function() { return false; });			// false -> not mutated
	this.essentialGenes = d3.range(settings.e).map(function() { return false; })
	this.genes = d3.range(settings.n-settings.d-settings.e).map(function() { return false; });		// false -> not mutated
	if (i>0) {
		var parentCell = cells[Math.floor(Math.random()*i)];
		this.x = Math.cos(this.randomAngle)*parentCell.radius + parentCell.x;
		this.y = Math.sin(this.randomAngle)*parentCell.radius + parentCell.y;		
	}
	return this;
}

var addCell = function(nr) {
	if (nr===undefined) nr = 1;
	for(var i=0; i<nr; i++) {
		cells.push(new Cell());
	}
	updateNodeDisplay();
}

var removeCell = function(nr) {
	if (nr===undefined) nr = 1;
	for(var i=0; i<Math.abs(nr); i++) {
		cells.pop();
	}
	updateNodeDisplay();
}

var addInitialCells = function(nr) {
	var intervalID = window.setInterval(function() {
		addCell();
		if (cells.length>=settings.initialCells) clearInterval(intervalID);
	}, 200);	
}();	// execute immeditaly



var cachedCellCounter = settings.initialCells;

var addAdditionalCells = function(nr) {
	console.log(nr);
	nr = cells.length + nr;
	if (nr===undefined) nr = 1;
	
//	if (simulating) return;
//	simulating = true;
	
	console.log(nr);
	
	var delay = 200;
	force.charge(0); // neutralize force
		
	var intervalID = window.setInterval(function() {
		
		// add cell
		var cell = cachedCells[cachedCellCounter]; 		// get next cached cell
		cachedCellCounter++;							// increase cached cell counter
		
		var parentCell = cachedCells[cell.parent];		// get parent cell with cell.parent it from cachedCells, because cells[] position will change when cells die
		cell.color = varyColor(parentCell.color);
		cell.x = Math.cos(cell.randomAngle)*parentCell.radius + parentCell.x;
		cell.y = Math.sin(cell.randomAngle)*parentCell.radius + parentCell.y;
		cells.push(cell);
		
		
		// check for dead cells and remove
		
		// update generation
		var now = cell.born;		// get the current time from the current cell's birth time
		$('#timeStep').text(now);
		
		var cellsToDelete = [];
		for (var i=0; i<cells.length; i++) {
			if ((cells[i].died !== undefined) && (now >= cells[i].died)) {
				cellsToDelete.push(i);
				cells[i].alive = false;
			}
		}
		for (var j = cellsToDelete.length-1; j>=0; j--) {
			var d = cellsToDelete[j];
			var deletedCell = cells.splice(d, 1); 
		}

		updateNodeDisplay();
		updateStreamData();
		
			
		if (cells.length>=nr) clearInterval(intervalID);
		
	}, delay);
	simulating = false;
}

function stopSimulation() {
	clearInterval(intervalID);
}

// start simulation with worker
//worker.postMessage(JSON.stringify({'message':'startSimulation', 'settings':settings, 'cells':cells}));


/* - - - - - - - - - Create Inital Cells  End - - - - - - - - - */




/* - - - - - - - - - Transpose Cells for Streamgraph - - - - - - - - - */

var streamData;
var streamDataOK = true;
var streamType = "silhouette";
var updateStreamData = function() {

	if (streamDataOK) {
		streamDataOK = false;
		var cell, lastCell,i,j,l;
		var streamSlice = 200; 					// number of sampled timepoints
		var lastCell = cells[cells.length-1];
		var maxTime = lastCell.born+1;	      // get latest time, add 1
		var last = lastCell.id;
	
		steps = maxTime / streamSlice;
	
		streamData = [];
	
		// create bare bones stream data array, populates with zeroes
		for (i=0; i<settings.initialCells; i++) {
			streamData[i] = [];
			for (j=0; j<streamSlice; j++) {
				streamData[i][j] = {'x':j, 'y':0};
			}
		}

		for(i=0; i<cells.length; i++) {
			cell = cells[i];
			var bin = Math.floor(cell.born/steps);
			streamData[cell.subtype][bin].y++;			// increase bin
		}
	
		for (i=0; i<settings.initialCells; i++) {
			for (j=1; j<streamSlice; j++) {
				streamData[i][j].y += streamData[i][j-1].y 
			}
		}
	
	//	console.timeEnd("stream");
	
		var n = 6, // number of layers
		    m = 200, // number of samples per layer
		    stack = d3.layout.stack().offset(streamType);		// silhouette wiggle expand zero

		var layer0 = stack(streamData);		// compute baseline
	
		var height = 100;

		x = d3.scale.linear()
		    .domain([0, m - 1])
		    .range([0, width]);

		y = d3.scale.linear()
		   	.domain([0, d3.max(streamData, function(layer) { return d3.max(layer, function(d) { return d.y0 + d.y; }); })])
		    .range([height, 0]);

		area = d3.svg.area()
		    .x(function(d) { return x(d.x); })
		    .y0(function(d) { return y(d.y0); })
		    .y1(function(d) { return y(d.y0 + d.y); });

		stream = d3.select("div#stream svg")
			.attr("shape-rendering", "geometricPrecision")		// geometricPrecision optimizeSpeed auto crispEdges
		    .attr("width", width)
		    .attr("height", height);

		stream.selectAll("path")
		    .data(streamData)
			.attr("d", area)
			.style("fill", function(d, i) { return getColor[i]; })
		  .enter().append("path")
		    .attr("d", area)
		    .style("fill", function(d, i) { return getColor[i]; });
		
		streamDataOK = true;
	}
}


/* - - - - - - - - - Create Inital Cells  End - - - - - - - - - */



/* - - - - - - - - - Summarize Cells - - - - - - - - - */

var summary = {};
summary.cells = [];
summary.map = [];
summary.cutoffCells = [];

// reduce driver genes
summary.reduce = function() {
	// create and index of genetically same cells
	summary.cells = [];
	summary.map = [];
	for (var i=0; i<cachedCells.length; i++) {
		var genes = cachedCells[i].driverGenes;
		genes = genes.toString().replace(/\d+/g, "1").replace(/false/g, "0").replace(/,/g, "");	// genes array to binary string
		genes = parseInt(genes,2); 							// binary string to decimal number
		if (summary.cells[genes] === undefined) {
			summary.cells[genes] = [i];	// new array with intial cell id
			summary.map.push(genes)
		} else if (summary.cells.length > 0) {
			summary.cells[genes].push(i);
		}
	}
	summary.length = this.map.length;
}
summary.getCellsByGene = function(geneArray) {
	var gene = geneArray.toString().replace(/\d+/g, "1").replace(/false/g, "0").replace(/,/g, "");
	gene = parseInt(gene,2);
	return summary.cells[gene];
}
summary.getCells = function(i) {
	return summary.cells[summary.map[i]];
}

summary.cluster = function() {
	// http://mus.org.uk/teapot/clustering-in-javascript/
	// https://github.com/harthur/clusterfck
	// https://code.google.com/p/figue/
}

summary.cutoff = function(threshold) {
	summary.cutoffCells = [];
	if (threshold === undefined) threshold = 0;
	summary.map.forEach(function(key, i) {
	//	console.log(key, i);
		
		var c = summary.getCells(i)
		if (c.length > threshold) {
			summary.cutoffCells[key] = c;
		}
	});
}

/* - - - - - - - - - Summarize Cells  End - - - - - - - - - */









/* - - - - - - - - - Save Frames - - - - - - - - - */

window.URL = (window.URL || window.webkitURL);

var animation = {};
animation.counter = 0;

animation.saveFrame = function(svgID) {
	// add backslashes to prevent PHP parsing
	var doctype = '<\?xml version="1.0" standalone="no"\?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">';
	
	var documents = [window.document];

	SVGSources = []; // public for testing

    documents.forEach(function(doc) {
      styles = getStyles(doc);			// public for testing
      newSources = getSources(doc, styles, svgID);	 // public for testing
      // because of prototype on NYT pages
      for (var i = 0; i < newSources.length; i++) {
        SVGSources.push(newSources[i]);
      };
    })

/*
    if (SVGSources.length > 1) {
      createPopover(SVGSources);
    } else if (SVGSources.length > 0) {
      download(SVGSources[0]);
    } else {
      alert("The Crowbar couldn’t find any SVG nodes.");
    }
*/

	if (SVGSources.length === 1) {
		download(SVGSources[0]);
	} else {
		alert("Couldn’t find any SVG nodes.");
	}
	
	
	function getSources(doc, styles, svgID) {
    var svgInfo = [],
        svgs = d3.select(doc).selectAll("svg" + svgID);  // limit selecti to on svg via ID

    styles = (styles === undefined) ? "" : styles;

    svgs.each(function () {
      var svg = d3.select(this);
      svg.attr("version", "1.1")
        .insert("defs", ":first-child")
          .attr("class", "svg-crowbar")
        .append("style")
          .attr("type", "text/css");

      // removing attributes so they aren't doubled up
      svg.node().removeAttribute("xmlns");
      svg.node().removeAttribute("xlink");

      // These are needed for the svg
      if (!svg.node().hasAttributeNS(d3.ns.prefix.xmlns, "xmlns")) {
        svg.node().setAttributeNS(d3.ns.prefix.xmlns, "xmlns", d3.ns.prefix.svg);
      }

      if (!svg.node().hasAttributeNS(d3.ns.prefix.xmlns, "xmlns:xlink")) {
        svg.node().setAttributeNS(d3.ns.prefix.xmlns, "xmlns:xlink", d3.ns.prefix.xlink);
      }

      var source = (new XMLSerializer()).serializeToString(svg.node()).replace('</style>', '<![CDATA[' + styles + ']]></style>');
      var rect = svg.node().getBoundingClientRect();
      svgInfo.push({
        top: rect.top,
        left: rect.left,
        width: rect.width,
        height: rect.height,
        class: svg.attr("class"),
        id: svg.attr("id"),
        childElementCount: svg.node().childElementCount,
        source: [doctype + source]
      });
    });
    return svgInfo;
  }

	
	
	function getStyles(doc) {
	    var styles = "",
	        styleSheets = doc.styleSheets;

	    if (styleSheets) {
	      for (var i = 0; i < styleSheets.length; i++) {
	        processStyleSheet(styleSheets[i]);
	      }
	    }
	    function processStyleSheet(ss) {
	      if (ss.cssRules) {
	        for (var i = 0; i < ss.cssRules.length; i++) {
	          var rule = ss.cssRules[i];
	          if (rule.type === 3) {
	            // Import Rule
	            processStyleSheet(rule.styleSheet);
	          } else {
	            // hack for illustrator crashing on descendent selectors
	            if (rule.selectorText) {
	              if (rule.selectorText.indexOf(">") === -1) {
	                styles += "\n" + rule.cssText;
	              }
	            }
	          }
	        }
	      }
	    }
	    return styles;
	  }
	
	  function download(source) {
		test = source;
		console.log("download", source);
	    var filename = "untitled";

		console.log("filename", filename);
		
	    if (source.id) {
	      filename = source.id;
	    } else if (source.class) {
	      filename = source.class;
	    } else if (window.document.title) {
	      filename = window.document.title.replace(/[^a-z0-9]/gi, '-').toLowerCase();
	    }

		filename = filename + "_"+ animation.counter;		// add counter to filename
		
		console.log("filename", filename);
		

	    var url = window.URL.createObjectURL(new Blob(source.source, { "type" : "text\/xml" }));

		// append blob as <a> 
	
	    var a = d3.select("body")
	        .append('a')
	  //     .attr("class", "svg-crowbar")
			.attr("id", filename)
	        .attr("download", filename + ".svg.txt")	// prevent Chrome form showing annoying Keep/Discard dialogue
	        .attr("href", url)
	        .style("display", "none");

		
	    a.node().click();								// click to download

		console.log(filename);
		// remove blob from document
		setTimeout(function() {
			window.URL.revokeObjectURL(url);			// releases blob from memory
			d3.selectAll("#"+filename).remove();		// remove <a> from DOM
	    }, 10);											// 10ms is enough?
	
	
		animation.counter++;							// update counter
		
	  }
	
	
}

/* - - - - - - - - - Save Frames End- - - - - - - - - */
 
</script>